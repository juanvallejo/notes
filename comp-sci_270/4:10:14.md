**Hash Function**

- h: key `->` address
- ideal is 1-1. rarely achieved due to `pigeon-hole principle`
- easy to map integer to address, whar about strings to address?
- creating huge tables is a waste of memory
- we will always have a situation where we need to add more keys than will fit
- **solution**
	- `modulo` is the remainder left after a division
	- `27 mod 2` is `1`, `28 mod 2` is `0`
	- divide the initial address value by the number of table slots
	- use the remainder as the address
	- `x mod y = 0 ... y-1`
- **Collision**
	- a collision occurs id h(x) == h(y) for any x <> y
		- ex. `h('post') == h('stop')`
- **collision likelyhood**
	- certainty if number of items to insert is more than number of slots (pigeon hole principle)
	- birthday problem is bad newss
	- the table doesn't have to be anywhere near full to geta  > 50% probability of collision (only about 6.3%)
	- MUST have collision resolution methods
- **Collision resolution**
	- Open Addressing: probe table for an empty slot
	- increase table size: tableInsert each item into a new larger table
	- Buckets / chaining: table slots contain collections rather than single elements
	- **Open addressing**
		- Search for next empty slot in table
		- linear probing: h(x), h(x)+1, h(x)+2...
		- quadratic probing: h(x), h(x) + 1^2
- **Double Hashing**
	- Use of buckets and storing value on h(x) + (second hash)
- **Efficiency**
	- intuitively, as the table gets fuller, it takes longer to find an empty slot
	- called the load factor, `α`
	- `α` = num of occupied slots / size of table
	- `α` should be kept less than `2/3`
- **Hash function issues**
	- should be simple and fast
	- should evenly distribute keys across all slots
	- can be affeted by patterns in data
	- use prime numbers for table sizes
	- `can't do ordered traversals`
- **Use all of the key**
	- b = number of buckets (slots)
	- h1(k) = [(int) k[0] + 10 * (int) k[1]] % b
	- h2(k) = similar to h1, but use all chars in the string
	- h1("papa") == h1("pasta") == ...etc
- **Applications**
	- Table ADT
	- Symbol table lookup in compilers
	- Error detection (send h (data) along with data)
	- Cryptography (send hash (Data), compare to stored hash)
- **File structure**
	- field is made up of characters, bytes, etc. Represents a class of information
	- record is made up of fields. represents a collection of field values for a particular entity
	- file is made up of records. represents a collection of related records.
- **Sequential file**
	- file is where records are stored one after aother (list of records)
	- logical structure matches physical structure of magnetic tape
	- implemented with pointers on a hard disk
- **Blocks and records**
	- Because disk access is costly (slow), want to minimize it
	- shouldn't read/write one character at a time from/to a file
	- access a whole block at a time
	- use buffer in memory to make changes
	- write buffer back to block in hard drive
- **Buffered IO**
	- `System.out.print` sends characters to a buffer (RAM)
	- When `\n` is detected, buffer is flushed (written to hard drive)
	- `System.out.flush` or use `println`
	- Other languages flush when buffer is full
	- If error halts program before flush, won't see output
- **Basic strategy**
	- identify file block that contains record
	- read  that block into buffer
	- perform operations on record in buffer
	- write buffer back to that block in file
- **External sort**
	- suppose data to be sorted can't all fit in primary memory
	- must access secondary storage
	- what sort algorithm would require minimum access
- **External mergeSort**
	- mergesort only needs to access first element in each sorted list
	- mergesort only moves forward through the lists
	- O(nlogn) algorithm
	- what files do we need?
- **Strategy**
	- Let F be the input file to be sorted
	- two files F1 and F2 as work files
	- three buffers: two inputs, one input
	- sort each block
	- merge the sorted blocks
- ****